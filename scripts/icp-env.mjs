import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';

const projectRoot = process.cwd();
const environment = process.env.ICP_ENVIRONMENT || 'local';
const mappingCandidates = [
  path.join(
    projectRoot,
    '.icp',
    'cache',
    'mappings',
    `${environment}.ids.json`,
  ),
  path.join(projectRoot, '.icp', 'data', 'mappings', `${environment}.ids.json`),
];

const mappingPath = mappingCandidates.find((candidate) =>
  fs.existsSync(candidate),
);
if (!mappingPath) {
  const tried = mappingCandidates
    .map((candidate) => `  - ${candidate}`)
    .join('\n');
  console.error(
    `No icp-cli canister ID mapping found for environment "${environment}".\n` +
      'Run `icp deploy` first, then re-run this script.\n' +
      `Searched:\n${tried}`,
  );
  process.exit(1);
}

const mapping = JSON.parse(fs.readFileSync(mappingPath, 'utf8'));
const entries = Object.entries(mapping);
if (entries.length === 0) {
  console.error(`Mapping file is empty: ${mappingPath}`);
  process.exit(1);
}

const envLines = [];
const dfxNetwork = environment === 'ic' ? 'ic' : environment;

envLines.push('# Generated by npm run icp:env');
envLines.push(`DFX_NETWORK=${dfxNetwork}`);

for (const [name, canisterId] of entries) {
  const key = `CANISTER_ID_${name.toUpperCase().replace(/-/g, '_')}`;
  envLines.push(`${key}=${canisterId}`);
}

envLines.push('');
fs.writeFileSync(path.join(projectRoot, '.env'), envLines.join('\n'), 'utf8');

console.log(`Wrote .env using ${path.relative(projectRoot, mappingPath)}`);
